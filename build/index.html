<!doctype html>
<html>
<head>
    <title>Pipes game</title>
    <style>
        body {
            background-color: gray;
            text-align: center;
			font-family:verdana;
        }
		
		p {
			text-align:left;
		}
		
        #btnNew{
            border: 1px solid gray;
        }
        #timer, #controls, #canvasContainer{
            font-weight: 600;
            width:500px;
            margin-left: auto;
            margin-right: auto;
            color: white;
            background-color:black;
        }
		
        #canvasContainer{
            height:500px;
        }
		#description{
			width:500px;
            margin-left: auto;
            margin-right: auto;
			background-color:white;
			margin-top:10px;
			padding:5px;
			border: 2px solid black;
			border-radius: 25px;
		}
        canvas {
            width: 500px;
            height: 500px;
        }
        
        a:link {
            text-decoration: none;
            color: white;
        }

        a:visited {
            text-decoration: none;
            color: white;
        }

        a:hover {
            text-decoration: none;
            color: white;
        }

        a:active {
            text-decoration: none;
            color: white;
        } 
        
    </style>
    <script>
        var gameContext = null,
            timer = null;

        function initGame() {
            var canvas = document.getElementById("game");
            gameContext = new Context2D(canvas, 10, 10);
            gameContext.start();
            canvas.addEventListener('contextmenu', function (event) { event.preventDefault(); }, false);

            gameContext.canvas.addEventListener('mousedown', canvasClick, false);
            gameContext.canvas.addEventListener('touchstart', canvasTouch, false);

            var timerContainer = document.getElementById("timer");
            timer = new Timer(timerContainer);
            timer.start();
        }
        
        //events
        function canvasClick(event) {
            event.preventDefault();
            gameContext.click(event.button, event.clientX, event.clientY, onWin);
        }

        function canvasTouch(event) {
            event.preventDefault();
            gameContext.click(0, event.touches[0].pageX, event.touches[0].pageY, onWin);
        }

        function onWin() {
            gameContext.canvas.removeEventListener('mousedown', canvasClick, false);
            gameContext.canvas.removeEventListener('touchstart', canvasTouch, false);
        }

        window.onload = initGame;
		
		/*
		 * binds an function to a scope in which it will be running, useful on events
		 */
		function bind(scope, fn) {
			return function () {
				fn.apply(scope, arguments);
			};
		}

		/*
		 * different ajax calls on multiple places made easier
		 */
		function callAjax(url, data, fsuccess, ferror) {
			if (ferror === undefined) ferror = function (xhr, ajaxOptions, thrownError) {
				alert(xhr.status);
				alert(thrownError);
			}
			$.ajax({
				type: "POST",
				url: url,
				data: JSON.stringify(data || {}),
				contentType: "application/json; charset=utf-8",
				dataType: "json",
				success: fsuccess,
				error: ferror
			});
		}

		function random(min, max) {
			return Math.floor(Math.random() * (max - min + 1) + min);
		}
		
		Timer = function (container) {
			this.container = container;
		}

		Timer.prototype = {
			startTime: null,
			container: null,
			timerIntervalVar: null,
			maxSeconds: 999,

			constructor: Timer,
			
			start: function () {
				this.startTime = new Date();
				this.container.innerText = 0;
				this.timerIntervalVar = setInterval(bind(this,this.reTime, 500));
			},
			reTime: function(){
				var currentTime = new Date();
				var timeDiff = Math.abs(currentTime.getTime() - this.startTime.getTime());
				var seconds = Math.floor(timeDiff / 1000);
				if (seconds < this.maxSeconds) {
					var timeStrLen = ("" + seconds).length;
					for (var i = 0; i < 3 - timeStrLen; i++) {
						seconds = "0" + seconds;
					}
					this.container.innerHTML = "Timer: " + seconds;
				}
				else {
					//I would say it's an easter egg, but since this is open source, I don't know...
					this.container.innerHTML = "You are taking too long, I quit! <br/><br/> Kind regards,<br/> timer.";
					this.stop();
				}
				

			},
			stop: function () {
				clearInterval(this.timerIntervalVar);
			}
		}
		
		Context2D = function (canvas, rows, columns) {
		this.gl = canvas.getContext("2d");
		this.engine = new Engine(rows, columns);
		this.canvas = canvas;
		this.stepX = (this.canvas.width - 1) / this.engine.columns;
		this.stepY = (this.canvas.height - 1) / this.engine.rows;
	}

	Context2D.prototype = {
		gl: null,
		engine: null,
		canvas: null,
		constructor: Context2D,

		draw: function(){
			var gl = this.gl;
			gl.globalAlpha = 1;
			gl.fillStyle = "Black";
			gl.fillRect(0, 0, this.canvas.width, this.canvas.height);

			//draw grid lines
			gl.strokeStyle = "Gray";
			gl.lineWidth = 1;
			gl.beginPath();
			var positionX = 0,
				positionY = 0;
			
			//vertical lines by columns
			for (var i = 0; i <= this.engine.columns; i++) {
				positionX = Math.floor(i * this.stepX) + 0.5;
				gl.moveTo(positionX, 0);
				gl.lineTo(positionX, this.canvas.height);
			}
			//horizontal lines by rows
			for (var i = 0; i <= this.engine.rows; i++) {
				positionY = Math.floor(i * this.stepY) + 0.5;
				gl.moveTo(0, positionY);
				gl.lineTo(this.canvas.width, positionY);
			}
			gl.stroke();

			//draw cells
			gl.lineWidth = 3;
			for (var i = 0; i < this.engine.columns; i++) {
				for (var j = 0; j < this.engine.rows; j++) {
					positionX = Math.floor(i * this.stepX + this.stepX / 2) + 0.5;
					positionY = Math.floor(j * this.stepY + this.stepY / 2) + 0.5;
					var cell = this.engine.map[i][j];

					//locked cell
					if (cell.locked) {
						gl.fillStyle = "#0A2A0A";
						gl.fillRect(positionX - this.stepX / 2, positionY - this.stepY / 2, this.stepX, this.stepY);
					}

					//source cell
					if (this.engine.startCell.i == i && this.engine.startCell.j == j) {
						var grd = gl.createRadialGradient(positionX, positionY, 1,
							positionX, positionY, Math.min(this.stepX/2, this.stepY/2));
						grd.addColorStop(0, "green");
						grd.addColorStop(1, "transparent");
						gl.fillStyle = grd;
						gl.fillRect(positionX - this.stepX / 2, positionY - this.stepY / 2, this.stepX, this.stepY);
					}

					//cell circuit lines
					gl.beginPath();
					if (cell.left) {
						gl.moveTo(positionX, positionY);
						gl.lineTo(positionX - this.stepX / 2, positionY);
					}
					if (cell.right) {
						gl.moveTo(positionX, positionY);
						gl.lineTo(positionX + this.stepX / 2, positionY);
					}
					if (cell.up) {
						gl.moveTo(positionX, positionY);
						gl.lineTo(positionX, positionY - this.stepY / 2);
					}
					if (cell.down) {
						gl.moveTo(positionX, positionY);
						gl.lineTo(positionX, positionY + this.stepY / 2);
					}
					if (cell.connected) {
						gl.strokeStyle = "Chartreuse ";
					} else {
						gl.strokeStyle = "White";
					}
					gl.stroke();
				}
			}
		},

		drawWin: function(){
			var gl = this.gl;
			gl.globalAlpha = 0.8;
			gl.fillStyle = "Black";
			gl.fillRect(0, 0, this.canvas.width, this.canvas.height);

			gl.textAlign = 'center';
			gl.font = '30pt Calibri';
			gl.fillStyle = 'Chartreuse';
			gl.fillText('You won!', this.canvas.width / 2, this.canvas.height / 2);
		},
		start: function(){
			this.engine.restart();
			this.draw();
		},

		click: function (button, x, y, onWin) {
			var rect = this.canvas.getBoundingClientRect();
			var i = Math.floor((x - rect.left) / this.stepX);
			var j = Math.floor((y - rect.top) / this.stepX);

			//cannot rotate on locked cells
			if (!this.engine.map[i][j].locked) {
				//left click, rotate counter clockwise
				if (button === 0) {
					this.engine.rotateCellCCW(i, j);
				}
				//right click, rotate clockwise
				else if (button === 2) {
					this.engine.rotateCellCW(i, j);
				}
			}
			//lock a cell
			if (button === 1) {
				this.engine.toggleLock(i,j);
			}
			this.engine.resetConnections();
			this.draw();
			if (this.engine.checkSolution()) {
				this.drawWin();
				timer.stop();
				onWin.call();
			}
		}
	}
	
	Engine = function (rows, columns) {
		this.rows = rows;
		this.columns = columns;
	}

	Engine.prototype = {
		cellTypes: [
			["up"],
			["up", "right"],
			["up", "down"],
			["up", "down", "right"],
			["up", "down", "left", "right"]
		],
		rows: 0,
		columns: 0,
		map: [],
		startCell: { i: 0, j: 0 },
		direction: {
			any: 0,
			left: 1,
			right: 2,
			up: 3,
			down: 4
		},

		constructor: Engine,
		
		initMap : function(randomize){
			this.map = [];
			for (var i = 0; i < this.rows; i++) {
				this.map[i] = [];
				for (var j = 0; j < this.columns; j++) {
					this.map[i][j] = randomize ? this.createRandomCell() : this.createEmptyCell();
				}
			}
		},

		createEmptyCell: function (connected) {
			return {
				up: false,
				down: false,
				left: false,
				right: false,
				connected: !!connected,
				locked: false
			}
		},

		//needed this on initial engine testing
		createRandomCell: function (connected) {
			return {
				up: !!random(0,1),
				down: !!random(0, 1),
				left: !!random(0, 1),
				right: !!random(0, 1),
				connected: !!connected,
				locked: false
			}
			
		},

		rotateCellCCW: function (i, j) {
			var cell = this.map[i][j];
			var temp = cell.left;
			cell.left = cell.up;
			cell.up = cell.right;
			cell.right = cell.down;
			cell.down = temp;
		},

		rotateCellCW: function (i, j) {
			var cell = this.map[i][j];
			var temp = cell.left;
			cell.left = cell.down;
			cell.down = cell.right;
			cell.right = cell.up;
			cell.up = temp;
		},

		resetConnections: function(){
			for (var i = 0; i < this.rows; i++) {
				for (var j = 0; j < this.columns; j++) {
					this.map[i][j].connected = false;
				}
			}
			this.connect(this.startCell.i,this.startCell.j,this.direction.any);
		},

		connect: function (i,j, direction) {
			var cell = this.map[i][j];
			if (!!cell && !cell.connected && this.resolveDirection(i,j,direction)) {
				cell.connected = true;
				if (cell.left && i>0) {
					this.connect(i - 1, j, this.direction.right);
				}
				if (cell.right && i < this.columns-1) {
					this.connect(i + 1, j, this.direction.left);
				}
				if (cell.up && j >0) {
					this.connect(i, j - 1, this.direction.down);
				}
				if (cell.down && j< this.rows-1) {
					this.connect(i, j + 1, this.direction.up);
				}
			}
		},
		resolveDirection: function(i,j,direction){
			if (direction == this.direction.any) return true;
			if (direction == this.direction.left && this.map[i][j].left) return true;
			if (direction == this.direction.right && this.map[i][j].right) return true;
			if (direction == this.direction.up && this.map[i][j].up) return true;
			if (direction == this.direction.down && this.map[i][j].down) return true;
			return false;
		},
		restart: function(){
			var i = Math.floor(Math.random() * 9),
			j = Math.floor(Math.random() * 9);

			this.startCell = {
				i: i,
				j: j
			}
			//init map
			this.initMap();
			this.generateMap(games);
			this.resetConnections();
		},
		generateMap: function (mapData) {
			for (var i = 0; i < 10; i++) {
				for (var j = 0; j < 10; j++) {
					var cellType = this.cellTypes[mapData[i][j]];
					for (var p = 0; p < cellType.length; p++) {
						this.map[j][i][cellType[p]] = true;
					}
					var rand = random(0, 3);
					while (rand--) {
						this.rotateCellCCW(j, i);
					}
				}
			}
		},
		checkSolution: function () {
			for (var i = 0; i < 10; i++) {
				for (var j = 0; j < 10; j++) {
					if (!this.map[i][j].connected) return false;
				}
			}
			return true;
		},
		toggleLock: function (i, j) {
			this.map[i][j].locked = !this.map[i][j].locked;
		}
	}
	
	games = [
		[0, 3, 0, 1, 2, 2, 2, 1, 0, 1],
		[0, 3, 1, 0, 1, 3, 1, 3, 2, 3],
		[1, 1, 3, 3, 3, 0, 1, 1, 0, 0],
		[2, 1, 1, 2, 1, 2, 0, 0, 4, 1],
		[2, 0, 2, 1, 1, 0, 0, 3, 1, 2],
		[3, 2, 1, 0, 3, 3, 2, 1, 0, 3],
		[2, 0, 3, 2, 3, 1, 0, 1, 2, 3],
		[2, 1, 1, 1, 3, 0, 3, 3, 1, 1],
		[2, 0, 1, 1, 3, 3, 0, 2, 1, 0],
		[1, 1, 1, 0, 0, 1, 0, 1, 2, 0]
	]
    </script>
</head>
<body>
    <div id="timer"></div>
	<div id="canvasContainer">
        <canvas id="game" width="500" height="500" >
			Unfortunately, your browser does not support HTML5 canvas element.
		</canvas>
    </div>
    <div id="controls" ><a href="index.html" >New game</a></div>
	<div id="description" >
		<h4>Hot to play?</h4>
		<p>One needs to rotate cells so their alignment can allow the current to pass through them. There is one green radial source of the current, that can also be rotated. A cell has a current flowing through it when it turns green.</p>
		<h4>Controls</h4>
		<p>Left click = Rotate counter-clockwise<br/>Right click = Rotate clockwise<br/>Middle click = lock a cell against rotation</p>
	</div>
</body>
</html>